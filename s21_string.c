#include "s21_string.h"

/**
 * @brief Поиск первого вхождения байта в блок памяти.
 *
 * Эта функция осуществляет поиск в первых @p n байтах блока памяти,
 * на который указывает @p str, первого вхождения байта @p c (рассматриваемого
 * как беззнаковый char).
 *
 * @param str Указатель на блок памяти, в котором осуществляется поиск.
 * @param c   Байт, значение которого нужно найти.
 * @param n   Количество байт, которые нужно проверить.
 *
 * @return Указатель на первое вхождение @p c в блок памяти,
 *         на который указывает @p str, или нулевой указатель, если @p c
 *         не найден в первых @p n байтах.
 */
void *s21_memchr(const void *str, int c, s21_size_t n) {
  const unsigned char *s = (const unsigned char *)str;
  unsigned char uc = (unsigned char)c;

  // Проходим через блок памяти
  for (s21_size_t i = 0; i < n; ++i) {
    // Если текущий байт совпадает с целевым байтом
    if (s[i] == uc) {
      // Возвращаем указатель на совпавший байт
      return (void *)(s + i);
    }
  }

  // Если байт не найден в первых n байтах, возвращаем NULL
  return s21_NULL;
}

/**
 * @brief Сравнение блоков памяти.
 *
 * Эта функция сравнивает первые @p n байтов блоков памяти, на которые
 * указывают @p str1 и @p str2.
 *
 * @param str1 Указатель на первый блок памяти для сравнения.
 * @param str2 Указатель на второй блок памяти для сравнения.
 * @param n    Количество байтов для сравнения.
 *
 * @return Значение:
 *         - 0, если блоки памяти равны;
 *         - отрицательное число, если первый несовпадающий байт в str1
 *           меньше соответствующего байта в str2;
 *         - положительное число, если первый несовпадающий байт в str1
 *           больше соответствующего байта в str2.
 */
int s21_memcmp(const void *str1, const void *str2, s21_size_t n) {
  const unsigned char *s1 = (const unsigned char *)str1;
  const unsigned char *s2 = (const unsigned char *)str2;

  // Проходим через блоки памяти
  for (s21_size_t i = 0; i < n; ++i) {
    // Если текущие байты не совпадают
    if (s1[i] != s2[i]) {
      // Возвращаем разницу между значениями байтов
      return s1[i] - s2[i];
    }
  }

  // Если блоки памяти равны, возвращаем 0
  return 0;
}

/**
 * @brief Копирование блока памяти.
 *
 * Эта функция копирует @p n байтов из блока памяти, на который указывает @p
 * src, в блок памяти, на который указывает @p dest. Оба блока памяти не должны
 * перекрываться.
 *
 * @param dest Указатель на блок памяти, куда будут скопированы данные.
 * @param src  Указатель на блок памяти, который будет скопирован.
 * @param n    Количество байтов для копирования.
 *
 * @return Указатель на начало блока памяти, куда были скопированы данные (@p
 * dest).
 */
void *s21_memcpy(void *dest, const void *src, s21_size_t n) {
  // Приводим указатели к типу char для работы с байтами
  char *destination = (char *)dest;
  const char *source = (const char *)src;

  // Копируем каждый байт из source в destination
  for (s21_size_t i = 0; i < n; ++i) {
    destination[i] = source[i];
  }

  // Возвращаем указатель на начало destination
  return dest;
}

/**
 * @brief Заполнение блока памяти заданным значением.
 *
 * Эта функция устанавливает значение @p c (приведенное к типу unsigned char)
 * для каждого из первых @p n байтов блока памяти, на который указывает @p str.
 *
 * @param str Указатель на блок памяти, который будет заполнен.
 * @param c   Значение, которым будет заполнен блок памяти.
 * @param n   Количество байтов для заполнения.
 *
 * @return Указатель на начало блока памяти, который был заполнен (@p str).
 */
void *s21_memset(void *str, int c, s21_size_t n) {
  unsigned char *s =
      (unsigned char *)str;  // Приводим указатель к типу unsigned char
  unsigned char uc =
      (unsigned char)c;  // Приводим значение к типу unsigned char

  // Заполняем каждый байт блока памяти значением uc
  for (s21_size_t i = 0; i < n; ++i) {
    s[i] = uc;
  }

  // Возвращаем указатель на начало блока памяти
  return str;
}

/**
 * @brief Копирование строки с ограничением по количеству символов.
 *
 * Эта функция копирует не более @p n символов из строки @p src в строку @p
 * dest. Если строка @p src содержит меньше символов, чем @p n, то в результате
 * копирования в строку @p dest будет добавлен нулевой символ до заполнения @p n
 * символов.
 *
 * @param dest Указатель на строку, куда будет производиться копирование.
 * @param src  Указатель на исходную строку, которую нужно скопировать.
 * @param n    Максимальное количество символов для копирования, включая
 * завершающий нулевой символ.
 *
 * @return Указатель на начало строки, куда было скопировано содержимое (@p
 * dest). Если @p dest или @p src являются нулевыми указателями, функция вернет
 * нулевой указатель.
 */
char *s21_strncpy(char *dest, const char *src, s21_size_t n) {
  // Проверяем, являются ли указатели нулевыми
  if (dest == s21_NULL || src == s21_NULL) {
    return s21_NULL;  // Если переданы нулевые указатели, возвращаем нулевой
                      // указатель
  }

  char *original_dest =
      dest;  // Сохраняем указатель на начало строки-назначения

  // Копируем символы из строки-источника в строку-назначение, пока не достигнем
  // конца строки-источника или не скопируем n символов
  while (n > 0 && *src != '\0') {
    *dest = *src;  // Копируем символ из строки-источника в строку-назначение
    dest++;  // Увеличиваем указатель на строку-назначение
    src++;  // Увеличиваем указатель на строку-источник
    n--;  // Уменьшаем счетчик скопированных символов
  }

  // Если в строке-назначении осталось место, добавляем нулевой символ
  while (n > 0) {
    *dest = '\0';  // Добавляем нулевой символ
    dest++;  // Увеличиваем указатель на строку-назначение
    n--;     // Уменьшаем счетчик
  }

  return original_dest;  // Возвращаем указатель на начало строки-назначения
}

/**
 * @brief Определение длины начального сегмента строки, не содержащего символы
 * из указанной строки.
 *
 * Эта функция вычисляет длину начального сегмента строки @p str1, который не
 * содержит символы из строки @p str2. Функция прекращает счет, как только
 * встречается символ, присутствующий в @p str2, или при достижении завершающего
 * нулевого символа строки @p str1.
 *
 * @param str1 Указатель на строку, в которой ищется начальный сегмент.
 * @param str2 Указатель на строку, символы которой исключаются из начального
 * сегмента.
 *
 * @return Длина начального сегмента строки @p str1, не содержащего символы из
 * @p str2. Если переданы нулевые указатели, функция вернет 0.
 */
s21_size_t s21_strcspn(const char *str1, const char *str2) {
  // Проверяем, являются ли указатели нулевыми
  if (str1 == s21_NULL || str2 == s21_NULL) {
    return 0;  // Если переданы нулевые указатели, возвращаем 0
  }

  const char *p;
  const char *s;
  s21_size_t count = 0;

  // Проходим по строке str1
  for (p = str1; *p != '\0'; p++) {
    // Проходим по строке str2
    for (s = str2; *s != '\0'; s++) {
      if (*p == *s) {
        return count;  // Если символ из str1 найден в str2, возвращаем текущее
                       // значение count
      }
    }
    count++;  // Увеличиваем count, так как текущий символ из str1 не найден в
              // str2
  }

  return count;  // Если не найдено совпадений, возвращаем длину строки str1
}

/**
 * @brief Определение длины начального сегмента строки, содержащего только
 * символы из указанной строки.
 *
 * Эта функция вычисляет длину начального сегмента строки @p str1, который
 * содержит только символы, присутствующие в строке @p str2. Функция прекращает
 * счет, как только встречается символ, отсутствующий в @p str2, или при
 * достижении завершающего нулевого символа строки @p str1.
 *
 * @param str1 Указатель на строку, в которой ищется начальный сегмент.
 * @param str2 Указатель на строку, символы которой присутствуют в начальном
 * сегменте.
 *
 * @return Длина начального сегмента строки @p str1, содержащего только символы
 * из @p str2.
 */
s21_size_t s21_strspn(const char *str1, const char *str2) {
  s21_size_t counter = 0;

  // Проходим по строке str1
  for (const char *a = str1; *a; a++) {
    unsigned short was = 0;
    // Проходим по строке str2
    for (const char *b = str2; *b; b++) {
      if (*a == *b) {
        counter++;
        was = 1;
        break;
      }
    }
    if (!was) break;  // Если символ из str1 не найден в str2, прекращаем счет
  }
  return counter;
}

/**
 * @brief Находит первое вхождение любого символа из строки str2 в строке str1.
 *
 * Эта функция возвращает указатель на первое вхождение любого символа из строки
 * @p str2 в строке @p str1. Если такого символа нет в @p str1, возвращается
 * нулевой указатель.
 *
 * @param str1 Указатель на строку, в которой происходит поиск.
 * @param str2 Указатель на строку, символы которой ищутся в строке str1.
 *
 * @return Указатель на первое вхождение символа из @p str2 в @p str1, или
 * нулевой указатель, если символ не найден.
 */
char *s21_strpbrk(const char *str1, const char *str2) {
  char *res = s21_NULL;

  // Находим длину начального сегмента str1, не содержащего символы из str2
  s21_size_t index = s21_strcspn(str1, str2);

  // Если index не равен длине str1 и str1 не оканчивается нулевым символом,
  // значит, найден символ из str2 в str1
  if (index != s21_strlen(str1) && *str1 != '\0') {
    res = (char *)str1 + index;  // Устанавливаем указатель на найденный символ
  }

  return res;
}

s21_size_t s21_strlen(const char *str) {
  s21_size_t len = 0;
  if (str) {
    for (int i = 0; str[i]; i++) len++;
  }
  return len;
}

/**
 * @brief Добавляет первые @p n символов из строки @p str2 в конец строки @p
 * str1.
 *
 * Эта функция добавляет первые @p n символов из строки @p str2 в конец строки
 * @p str1. Результат записывается в @p str1.
 *
 * @param str1 Указатель на строку, в которую добавляются символы.
 * @param str2 Указатель на строку, из которой копируются символы.
 * @param n Количество символов из @p str2, которые нужно скопировать.
 *
 * @return Указатель на @p str1.
 */
char *s21_strncat(char *str1, const char *str2, s21_size_t n) {
  // Находим длину строки str1
  s21_size_t dest_len = s21_strlen(str1);
  s21_size_t i = 0;

  // Копируем первые n символов из str2 в конец str1
  for (; i < n && str2[i]; i++) {
    str1[dest_len + i] = str2[i];
  }

  // Устанавливаем нулевой символ в конце строки str1
  str1[dest_len + i] = '\0';

  return str1;
}

/**
 * @brief Вставляет строку @p str в строку @p src, начиная с позиции @p
 * start_index.
 *
 * Эта функция вставляет строку @p str в строку @p src, начиная с позиции @p
 * start_index. Результат записывается в новую динамически выделенную строку.
 *
 * @param src Указатель на исходную строку.
 * @param str Указатель на строку, которую нужно вставить.
 * @param start_index Индекс, с которого начинается вставка строки @p str в @p
 * src.
 *
 * @return Указатель на новую строку, в которую вставлена строка @p str, или
 * NULL в случае ошибки.
 */
char *s21_insert(const char *src, const char *str, s21_size_t start_index) {
  if (src == s21_NULL || str == s21_NULL) {
    return s21_NULL;  // Проверка на нулевые указатели
  }

  s21_size_t src_len = s21_strlen(src);
  s21_size_t str_len = s21_strlen(str);

  if (start_index > src_len) {
    return s21_NULL;  // Проверка, что start_index не превышает длину строки src
  }

  // Выделение памяти для новой строки
  char *new_str = (char *)malloc((src_len + str_len + 1) * sizeof(char));
  if (new_str == s21_NULL) {
    return s21_NULL;  // Проверка на успешное выделение памяти
  }

  // Копирование src в новую строку до start_index
  s21_memcpy(new_str, src, start_index);

  // Копирование str в новую строку начиная с start_index
  s21_memcpy(new_str + start_index, str, str_len);

  // Копирование оставшейся части src в новую строку
  s21_memcpy(new_str + start_index + str_len, src + start_index,
             src_len - start_index);

  // Установка завершающего нулевого символа
  new_str[src_len + str_len] = '\0';

  return new_str;
}

/**
 * @brief Выделяет память и копирует строку.
 *
 * @param src Исходная строка.
 * @return Возвращает указатель на новую копию строки или NULL, если не удалось
 * выделить память.
 */
char *s21_strdup(const char *src) {
  if (!src) return s21_NULL;

  // Определение длины строки src
  s21_size_t len = s21_strlen(src);

  // Выделение памяти под новую строку и проверка на успешное выделение
  char *dst = malloc(len + 1);
  if (!dst) return s21_NULL;

  // Копирование строки src в новый буфер
  s21_strncpy(dst, src, len);

  // Установка завершающего нулевого символа
  dst[len] = '\0';

  return dst;
}

/**
 * @brief Ищет первое вхождение символа в строке.
 *
 * @param str Строка для поиска.
 * @param c Искомый символ.
 * @return Указатель на первое вхождение символа в строке или NULL, если символ
 * не найден.
 */
char *s21_strchr(const char *str, int c) {
  int i = 0;
  // Поиск символа c в строке str
  while (str[i] && str[i] != c) i++;
  // Возвращаем указатель на первое вхождение символа или NULL, если символ не
  // найден
  return c == str[i] ? (char *)str + i : s21_NULL;
}

/**
 * @brief Удаляет пробельные символы с начала и конца строки.
 *
 * Эта функция удаляет пробельные символы с начала и конца строки @p src.
 * Пробельные символы определяются строкой @p trim_chars.
 *
 * @param src Указатель на исходную строку.
 * @param trim_chars Указатель на строку символов, которые нужно удалить.
 *
 * @return Указатель на новую строку без пробельных символов с начала и конца
 * исходной строки, или NULL в случае ошибки.
 */
void *s21_trim(const char *src, const char *trim_chars) {
  if (!src || !trim_chars)
    return s21_strdup("");  // Проверка на нулевые указатели

  s21_size_t src_len = s21_strlen(src);

  // Удаление начальных вхождений trim_chars
  s21_size_t start = 0;
  while (src[start] != '\0' && s21_strchr(trim_chars, src[start]) != s21_NULL) {
    start++;
  }

  // Удаление конечных вхождений trim_chars
  s21_size_t end = src_len;
  while (end > start && s21_strchr(trim_chars, src[end - 1]) != s21_NULL) {
    end--;
  }

  // Копирование оставшейся части строки
  char *trimmed_str = s21_strdup(src + start);
  if (!trimmed_str) return s21_NULL;
  trimmed_str[end - start] = '\0';  // Установка завершающего нуля
  return trimmed_str;
}

/**
 * @brief Сравнивает две строки до заданной длины.
 *
 * Функция сравнивает первые @p n символов строк @p str1 и @p str2.
 *
 * @param str1 Указатель на первую строку для сравнения.
 * @param str2 Указатель на вторую строку для сравнения.
 * @param n Максимальное количество символов для сравнения.
 *
 * @return Целое число меньше нуля, если первая строка меньше второй, равное
 * нулю, если строки равны, или больше нуля, если первая строка больше второй.
 */
int s21_strncmp(const char *str1, const char *str2, s21_size_t n) {
  int res = 0;
  while ((*str1 || *str2) && n--)
    if (*str1++ != *str2++) {
      res = (unsigned char)*--str1 - (unsigned char)*--str2;
      break;
    }
  return res;
}

/**
 * @brief Преобразует строку в целое число.
 *
 * Функция преобразует строку @p str в целое число типа int.
 *
 * @param str Строка для преобразования в целое число.
 *
 * @return Преобразованное целое число.
 */
int s21_atoi(const char *str) {
  int res = 0;
  int sign = 1;
  int overflow = 0;

  // Пропускаем пробельные символы
  while (*str == ' ') str++;

  // Определяем знак числа
  if (*str == '-') {
    str++;
    sign = -1;
  }

  if (*str == '+') {
    str++;
  }

  // Преобразуем символы в целое число
  while (*str && *str >= '0' && *str <= '9') {
    res = res * 10 + (*str - '0');
    // Проверяем на переполнение
    if (res < 0) {
      overflow = 1;
      break;
    }
    str++;
  }

  // Обрабатываем случай переполнения
  if (overflow)
    res = sign > 0 ? INT32_MAX : INT32_MIN;
  else
    res *= sign;

  return res;
}

/**
 * @brief Копирует строку.
 *
 * Функция копирует строку @p src в строку @p dest.
 *
 * @param dest Указатель на строку-назначение, куда будет скопирована строка @p
 * src.
 * @param src Указатель на строку-источник, которая будет скопирована.
 *
 * @return Указатель на строку-назначение @p dest.
 */
char *s21_strcpy(char *dest, const char *src) {
  // Копируем каждый символ из строки src в строку dest
  for (int i = 0; src[i]; i++) {
    dest[i] = src[i];
  }

  // Устанавливаем завершающий нулевой символ
  dest[s21_strlen(src)] = '\0';

  return dest;
}

/**
 * @brief Конкатенирует две строки.
 *
 * Функция конкатенирует строку @p src к строке @p dest.
 *
 * @param dest Указатель на строку-назначение, к которой будет присоединена
 * строка @p src.
 * @param src Указатель на строку, которая будет присоединена к строке @p dest.
 *
 * @return Указатель на строку-назначение @p dest.
 */
char *s21_strcat(char *dest, const char *src) {
  // Находим длину строки dest
  int dest_len = s21_strlen(dest);
  int i = 0;

  // Копируем символы из строки src в конец строки dest
  for (; src[i]; i++) {
    dest[dest_len + i] = src[i];
  }

  // Устанавливаем завершающий нулевой символ
  dest[dest_len + i] = '\0';

  return dest;
}

/**
 * @brief Копирует блок памяти с возможностью перекрытия.
 *
 * Функция копирует @p n байт из блока памяти, на который указывает @p src, в
 * блок памяти, на который указывает @p dest. Копирование происходит с учетом
 * возможного перекрытия блоков.
 *
 * @param dest Указатель на начало блока памяти, куда будет скопировано
 * содержимое.
 * @param src Указатель на начало блока памяти, из которого будет скопировано
 * содержимое.
 * @param n Количество байт, которые будут скопированы.
 *
 * @return Указатель на начало блока памяти, в который скопировано содержимое.
 */
void *s21_memmove(void *dest, const void *src, s21_size_t n) {
  // Приводим указатели к типу char для работы с байтами
  char *to = (char *)dest;
  char *from = (char *)src;

  // Выделяем временную память для копирования данных
  char *tmp = (char *)malloc(sizeof(char) * n);

  if (tmp) {
    // Копируем данные из src в tmp
    s21_memcpy(tmp, from, n);
    // Копируем данные из tmp в dest
    s21_memcpy(to, tmp, n);
    // Освобождаем временную память
    free(tmp);
  }

  return dest;
}

/**
 * @brief Проверяет, является ли символ цифрой.
 *
 * @param c Проверяемый символ.
 * @return Возвращает 1, если символ является цифрой, иначе возвращает 0.
 */
int s21_isdigit(char c) { return (c >= '0' && c <= '9'); }
